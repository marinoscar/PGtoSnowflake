import type { SourceTableMetadata, SourceColumn } from '../types/source-engine.js';
import type { SnowflakeColumn, SnowflakeForeignKey } from '../types/snowflake.js';
import { mapColumn as pgMapColumn } from './type-mapper.service.js';
import { DDLGenerationError } from '../utils/error.js';
import { logInfo, logDebug } from '../utils/log-file.js';

type ColumnMapper = (column: SourceColumn) => SnowflakeColumn;

function q(identifier: string): string {
  return `"${identifier}"`;
}

function generateHeader(): string {
  return `-- ============================================================
-- Snowflake DDL generated by db2snow
-- Generated at: ${new Date().toISOString()}
--
-- NOTE: Snowflake constraints (PRIMARY KEY, FOREIGN KEY, UNIQUE)
-- are declarative/informational only and are NOT enforced.
-- Only NOT NULL constraints are enforced by Snowflake.
-- ============================================================

`;
}

function generateSchemaStatements(schemas: string[]): string {
  return schemas
    .map((s) => `CREATE SCHEMA IF NOT EXISTS ${q(s)};`)
    .join('\n') + '\n\n';
}

function generateTableDDL(table: SourceTableMetadata, mapper: ColumnMapper): string {
  const columns = table.columns.map(mapper);
  const lines: string[] = [];

  for (const col of columns) {
    let line = `  ${q(col.name)} ${col.type}`;

    if (col.isIdentity) {
      line += ` IDENTITY(${col.identitySeed},${col.identityIncrement})`;
    }

    if (!col.nullable) {
      line += ' NOT NULL';
    }

    if (col.defaultValue && !col.isIdentity) {
      line += ` DEFAULT ${col.defaultValue}`;
    }

    lines.push(line);
  }

  // Add primary key constraint inline
  if (table.primaryKey && table.primaryKey.columns.length > 0) {
    const pkCols = table.primaryKey.columns.map(q).join(', ');
    lines.push(`  PRIMARY KEY (${pkCols})`);
  }

  let ddl = `CREATE TABLE IF NOT EXISTS ${q(table.schemaName)}.${q(table.tableName)} (\n`;
  ddl += lines.join(',\n');
  ddl += '\n);\n';

  // Add column comments
  for (const col of columns) {
    if (col.comment) {
      ddl += `COMMENT ON COLUMN ${q(table.schemaName)}.${q(table.tableName)}.${q(col.name)} IS '${col.comment.replace(/'/g, "''")}';` + '\n';
    }
  }

  return ddl;
}

function generateForeignKeys(tables: SourceTableMetadata[]): { sql: string; foreignKeys: SnowflakeForeignKey[] } {
  const fks: SnowflakeForeignKey[] = [];
  const statements: string[] = [];

  for (const table of tables) {
    for (const fk of table.foreignKeys) {
      const sfFk: SnowflakeForeignKey = {
        constraintName: fk.constraintName,
        schemaName: fk.schemaName,
        tableName: fk.tableName,
        columns: fk.columns,
        referencedSchema: fk.referencedSchema,
        referencedTable: fk.referencedTable,
        referencedColumns: fk.referencedColumns,
      };
      fks.push(sfFk);

      const fkCols = fk.columns.map(q).join(', ');
      const refCols = fk.referencedColumns.map(q).join(', ');

      statements.push(
        `ALTER TABLE ${q(fk.schemaName)}.${q(fk.tableName)} ADD CONSTRAINT ${q(fk.constraintName)} ` +
        `FOREIGN KEY (${fkCols}) REFERENCES ${q(fk.referencedSchema)}.${q(fk.referencedTable)} (${refCols});`,
      );
    }
  }

  return {
    sql: statements.length > 0 ? '\n-- Foreign Key Constraints\n' + statements.join('\n') + '\n' : '',
    foreignKeys: fks,
  };
}

export interface GenerateDDLResult {
  sql: string;
  schemaCount: number;
  tableCount: number;
  foreignKeyCount: number;
}

export async function generateDDL(
  tables: SourceTableMetadata[],
  columnMapper?: ColumnMapper,
): Promise<GenerateDDLResult> {
  const mapper = columnMapper ?? pgMapColumn;

  try {
    await logInfo('ddl-generator', `Generating DDL for ${tables.length} tables`);

    // Collect unique schemas
    const schemas = [...new Set(tables.map((t) => t.schemaName))].sort();

    let sql = generateHeader();
    sql += generateSchemaStatements(schemas);

    // Generate table DDL
    for (const table of tables) {
      await logDebug('ddl-generator', `Generating DDL for ${table.schemaName}.${table.tableName}`);
      sql += generateTableDDL(table, mapper) + '\n';
    }

    // Generate foreign keys (after all tables)
    const { sql: fkSql, foreignKeys } = generateForeignKeys(tables);
    sql += fkSql;

    await logInfo('ddl-generator', `DDL generation complete: ${schemas.length} schemas, ${tables.length} tables, ${foreignKeys.length} FKs`);

    return {
      sql,
      schemaCount: schemas.length,
      tableCount: tables.length,
      foreignKeyCount: foreignKeys.length,
    };
  } catch (err) {
    throw new DDLGenerationError('Failed to generate DDL', err instanceof Error ? err : undefined);
  }
}
